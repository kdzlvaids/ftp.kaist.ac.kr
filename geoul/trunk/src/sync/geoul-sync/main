#!/usr/bin/env bash
# geoul-sync -- A driver for synchronization scripts
# 
# Created: 2006-01-22
# 
# Written by Jaeho Shin <netj@sparcs.org>.
# (C) 2006-2009, Geoul Project. (http://project.sparcs.org/geoul)

## printers
usage() {
    local exitcode=$?
    [ $exitcode -eq 0 ] && exitcode=2
    local cmd=`basename "$0"`
    if [ -t 1 ]; then
        cat <<EOF
Geoul synchronizer for $pkg
Usage:
  $cmd now        use this to begin sync immediately
  $cmd pushed     use when upstream mirror is triggering push-mirroring
  $cmd regularly  check timestamp and begin sync if older than frequency
  $cmd stop       stop the synchronizing process

EOF
        [ $# -le 0 ] || echo "$cmd: $@"
    fi
    exit $exitcode
}
trap usage ERR
msg() { echo "$pkg: $@"; }
die() {
    local c=$1; shift
    echo "$pkg: $@"
    exit $c
}
err() { die "$@" >&2; }



script=$1; shift

## read package information
cd "`dirname "$script"`"
eval `load-package pkg name source frequency syncInProgress`


## choose what to do
triggered=$1
case "$triggered" in
    now|pushed) ;;
    regularly)
    [ -n "$frequency" ] || exit 6
    ;;
    stop) ;;
    watch) ;;
    *) usage ;;
esac


## check environment
# FIXME "$0"
[ x"`ps -o pgid= -p $$`" == x"$$" ] || exec setsid "$0" "$@"

shift
export GETARGS="$@"


## stop
if [ "$triggered" = stop ]; then
    if $syncInProgress; then
        lockproc lock kill
        die 0 "stopped running sync"
    else
        ruins=`find lock lock.* log log.* 2>/dev/null || true`
        if [ -n "$ruins" ]; then
            # TODO: clean up (as in finish)
            rm -f log log.*
            lockproc lock clean
            die 0 "cleaned up dead sync"
        else
            die 4 "no sync in progress"
        fi
    fi
fi


## jobs to be/not to be done while sync is in progress
if $syncInProgress; then
    case "$triggered" in
        watch)
        exec tail -f log
        ;;

        *) die 4 "another sync in progress" ;;
    esac
else
    case "$triggered" in
        now|pushed|regularly) ;;

        *) err 4 "no sync in progress" ;;
    esac
fi


## check timestamp if regular sync
eval `load-package timePastSecs intervalSecs numFailures penaltySecs delaySecs`
if [ "$triggered" = regularly ]; then
    desc=
    if [ $penaltySecs -gt 0 ]; then
        desc="=`iso-interval $intervalSecs`+`iso-interval $penaltySecs`(${numFailures} failures)"
    fi
    if [ $timePastSecs -lt $delaySecs ]; then
        die 8 "not yet (age=`iso-interval $timePastSecs` < `iso-interval $delaySecs`$desc)"
    else
        msg "old enough (age = `iso-interval $timePastSecs` >= `iso-interval $delaySecs`$desc)"
    fi
fi


# FIXME use synchronized

## lock this package
lockproc lock grab || die 4 "locked or another sync in progress"


## prepare logging and unlocking
# clean up last failure report flag
rm -f failed.needsreport
# create a new log
log=/mirror/log/sync/`date +%Y/%m/%d/%T.%N`.$pkg.log
mkdir -p `dirname $log`
: >$log
ln -sf $log log
if [ -t 1 ]; then
    # monitor log if connected to a terminal
    tail -f $log &
    tailpid=$!
fi
# backup stdout/err fd's and redirect everything to log
exec 3>&1- 4>&2-  >>$log 2>&1

# TODO remove this trap
finish() {
    trap '' EXIT ERR INT HUP TERM
    set +e
}
trap 'exitcode=$?; set +x; finish' EXIT ERR
trap 'exit 2' INT HUP TERM

eval `load-config sitename`

## now, the real synchronization begins
msg "sync begins at `humandate`"
cat <<EOF
+ source=$source
+ site=$sitename
+ node=$HOSTNAME
+ triggered=$triggered
+ frequency=$frequency
+ timepast=`iso-interval $timePastSecs`
+ failures=$numFailures
EOF

# run script
bash -x "$script"
exitcode=$?

result=
if [ $exitcode -eq 0 ]; then
    # record success
    result=success
    touch timestamp
    rm -f failed
else
    # record failure
    result=failure
    eval `load-package numFailures`
    # TODO: use lower bound?
    echo $(($numFailures + 1)) >failed
fi
msg "sync $result at `humandate`"
# stop monitoring log
if [ -n "$tailpid" ]; then
    sleep 1
    kill $tailpid 2>/dev/null
    wait $tailpid
fi
# restore stdout/err
exec >&3- 2>&4-
# save log
#  compress log
gzip -f $log
ln -sf $log.gz .$result.log.gz
rm -f log log.*
#  mark success/failure
case "$result" in
    failure)
    # raise need-to-report flag
    touch failed.needsreport
    # TODO: check sources, switch sources
    ;;
    success)
    ;;
esac
#  record to RSS
record-news.feed sync-$result $log.gz
#  TODO record-sync-cost using `collect-sync-cost $log.gz`
lockproc lock release

exit $exitcode
